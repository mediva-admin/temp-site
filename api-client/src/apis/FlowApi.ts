/* tslint:disable */
/* eslint-disable */
/**
 * Mediva API
 * Specification of the Mediva API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: admin@mediva.in
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BillableTokenResponse,
  CreateFlow,
  CreateFlowFromFlowTemplateRequest,
  ErrorResponse,
  Flow,
  FlowEntry,
  FlowHistory,
  MoveToNextTerminalRequest,
  MoveToNextTerminalResponse,
} from '../models/index';

export interface CreateFlowRequest {
    createFlow: CreateFlow;
}

export interface CreateFlowFromFlowTemplateOperationRequest {
    createFlowFromFlowTemplateRequest: CreateFlowFromFlowTemplateRequest;
}

export interface DeleteFlowByIdRequest {
    flowId: string;
}

export interface GetBillableTokensRequest {
    hospitalId: number;
}

export interface GetFlowByPatientRequest {
    patientId: string;
}

export interface MovePatientToNextTerminalRequest {
    flowId: string;
    moveToNextTerminalRequest: MoveToNextTerminalRequest;
}

export interface SaveFlowRequest {
    flowId: string;
}

export interface UpdateFlowDetailsRequest {
    flowId: string;
    flow: Flow;
}

export interface UpdateFlowEntriesRequest {
    flowId: string;
    flowEntry: Array<FlowEntry>;
}

export interface UpdateFlowEntryRequest {
    flowId: string;
    flowEntry: FlowEntry;
}

/**
 * FlowApi - interface
 * 
 * @export
 * @interface FlowApiInterface
 */
export interface FlowApiInterface {
    /**
     * 
     * @summary Create a flow for a patient in a hospital
     * @param {CreateFlow} createFlow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowApiInterface
     */
    createFlowRaw(requestParameters: CreateFlowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Flow>>;

    /**
     * Create a flow for a patient in a hospital
     */
    createFlow(createFlow: CreateFlow, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Flow>;

    /**
     * 
     * @summary Create a Flow from a Flow Template
     * @param {CreateFlowFromFlowTemplateRequest} createFlowFromFlowTemplateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowApiInterface
     */
    createFlowFromFlowTemplateRaw(requestParameters: CreateFlowFromFlowTemplateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Flow>>;

    /**
     * Create a Flow from a Flow Template
     */
    createFlowFromFlowTemplate(createFlowFromFlowTemplateRequest: CreateFlowFromFlowTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Flow>;

    /**
     * 
     * @summary Delete a flow by ID
     * @param {string} flowId ID of the flow to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowApiInterface
     */
    deleteFlowByIdRaw(requestParameters: DeleteFlowByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Delete a flow by ID
     */
    deleteFlowById(flowId: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Retrieves all billable tokens (flows) for a specific hospital with patient and billing information. Simple flow: 1. Get all flows for the hospital 2. Get patient info for each flow 3. Get billing info for each flow 4. Return combined results 
     * @summary Get billable tokens for a hospital
     * @param {number} hospitalId Unique identifier for the hospital
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowApiInterface
     */
    getBillableTokensRaw(requestParameters: GetBillableTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BillableTokenResponse>>>;

    /**
     * Retrieves all billable tokens (flows) for a specific hospital with patient and billing information. Simple flow: 1. Get all flows for the hospital 2. Get patient info for each flow 3. Get billing info for each flow 4. Return combined results 
     * Get billable tokens for a hospital
     */
    getBillableTokens(hospitalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BillableTokenResponse>>;

    /**
     * 
     * @summary Get flow for a patient in a hospital
     * @param {string} patientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowApiInterface
     */
    getFlowByPatientRaw(requestParameters: GetFlowByPatientRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Flow>>;

    /**
     * Get flow for a patient in a hospital
     */
    getFlowByPatient(patientId: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Flow>;

    /**
     * Moves a patient to the next terminal in their flow sequence. This is a comprehensive operation that:  1. **Saves Current Terminal Data**: Persists all collected terminal data before transfer 2. **Removes from Current Queue**: Removes patient from current terminal\'s active queue 3. **Adds to Next Terminal Queue**: Adds patient to the next terminal\'s queue with calculated position 4. **Updates Flow State**: Updates flow progress and current terminal information 5. **Recalculates Queue Timing**: Adjusts estimated start times for all affected patients 6. **Sends Notifications**: Informs patients about queue changes via WhatsApp  The operation handles the complete transfer process atomically, ensuring data consistency and proper queue management across terminals. 
     * @summary Move patient to next terminal in flow
     * @param {string} flowId Unique identifier for the flow to move patient to next terminal
     * @param {MoveToNextTerminalRequest} moveToNextTerminalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowApiInterface
     */
    movePatientToNextTerminalRaw(requestParameters: MovePatientToNextTerminalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MoveToNextTerminalResponse>>;

    /**
     * Moves a patient to the next terminal in their flow sequence. This is a comprehensive operation that:  1. **Saves Current Terminal Data**: Persists all collected terminal data before transfer 2. **Removes from Current Queue**: Removes patient from current terminal\'s active queue 3. **Adds to Next Terminal Queue**: Adds patient to the next terminal\'s queue with calculated position 4. **Updates Flow State**: Updates flow progress and current terminal information 5. **Recalculates Queue Timing**: Adjusts estimated start times for all affected patients 6. **Sends Notifications**: Informs patients about queue changes via WhatsApp  The operation handles the complete transfer process atomically, ensuring data consistency and proper queue management across terminals. 
     * Move patient to next terminal in flow
     */
    movePatientToNextTerminal(flowId: string, moveToNextTerminalRequest: MoveToNextTerminalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MoveToNextTerminalResponse>;

    /**
     * 
     * @summary Save flow into flow history
     * @param {string} flowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowApiInterface
     */
    saveFlowRaw(requestParameters: SaveFlowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FlowHistory>>;

    /**
     * Save flow into flow history
     */
    saveFlow(flowId: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FlowHistory>;

    /**
     * 
     * @summary Update entries of a flow
     * @param {string} flowId ID of the flow to delete
     * @param {Flow} flow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowApiInterface
     */
    updateFlowDetailsRaw(requestParameters: UpdateFlowDetailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Flow>>;

    /**
     * Update entries of a flow
     */
    updateFlowDetails(flowId: string, flow: Flow, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Flow>;

    /**
     * 
     * @summary Update entries of a flow
     * @param {string} flowId ID of the flow to delete
     * @param {Array<FlowEntry>} flowEntry 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowApiInterface
     */
    updateFlowEntriesRaw(requestParameters: UpdateFlowEntriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<FlowEntry>>>;

    /**
     * Update entries of a flow
     */
    updateFlowEntries(flowId: string, flowEntry: Array<FlowEntry>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<FlowEntry>>;

    /**
     * 
     * @summary Update a specific flow entry
     * @param {string} flowId 
     * @param {FlowEntry} flowEntry 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowApiInterface
     */
    updateFlowEntryRaw(requestParameters: UpdateFlowEntryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FlowEntry>>;

    /**
     * Update a specific flow entry
     */
    updateFlowEntry(flowId: string, flowEntry: FlowEntry, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FlowEntry>;

}

/**
 * 
 */
export class FlowApi extends runtime.BaseAPI implements FlowApiInterface {

    /**
     * Create a flow for a patient in a hospital
     */
    async createFlowRaw(requestParameters: CreateFlowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Flow>> {
        if (requestParameters['createFlow'] == null) {
            throw new runtime.RequiredError(
                'createFlow',
                'Required parameter "createFlow" was null or undefined when calling createFlow().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/flow/create`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['createFlow'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a flow for a patient in a hospital
     */
    async createFlow(createFlow: CreateFlow, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Flow> {
        const response = await this.createFlowRaw({ createFlow: createFlow }, initOverrides);
        return await response.value();
    }

    /**
     * Create a Flow from a Flow Template
     */
    async createFlowFromFlowTemplateRaw(requestParameters: CreateFlowFromFlowTemplateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Flow>> {
        if (requestParameters['createFlowFromFlowTemplateRequest'] == null) {
            throw new runtime.RequiredError(
                'createFlowFromFlowTemplateRequest',
                'Required parameter "createFlowFromFlowTemplateRequest" was null or undefined when calling createFlowFromFlowTemplate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/flow/create-from-template`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['createFlowFromFlowTemplateRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a Flow from a Flow Template
     */
    async createFlowFromFlowTemplate(createFlowFromFlowTemplateRequest: CreateFlowFromFlowTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Flow> {
        const response = await this.createFlowFromFlowTemplateRaw({ createFlowFromFlowTemplateRequest: createFlowFromFlowTemplateRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Delete a flow by ID
     */
    async deleteFlowByIdRaw(requestParameters: DeleteFlowByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['flowId'] == null) {
            throw new runtime.RequiredError(
                'flowId',
                'Required parameter "flowId" was null or undefined when calling deleteFlowById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/flow/{flowId}`;
        urlPath = urlPath.replace(`{${"flowId"}}`, encodeURIComponent(String(requestParameters['flowId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a flow by ID
     */
    async deleteFlowById(flowId: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteFlowByIdRaw({ flowId: flowId }, initOverrides);
    }

    /**
     * Retrieves all billable tokens (flows) for a specific hospital with patient and billing information. Simple flow: 1. Get all flows for the hospital 2. Get patient info for each flow 3. Get billing info for each flow 4. Return combined results 
     * Get billable tokens for a hospital
     */
    async getBillableTokensRaw(requestParameters: GetBillableTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BillableTokenResponse>>> {
        if (requestParameters['hospitalId'] == null) {
            throw new runtime.RequiredError(
                'hospitalId',
                'Required parameter "hospitalId" was null or undefined when calling getBillableTokens().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/flow/billable-tokens/{hospitalId}`;
        urlPath = urlPath.replace(`{${"hospitalId"}}`, encodeURIComponent(String(requestParameters['hospitalId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves all billable tokens (flows) for a specific hospital with patient and billing information. Simple flow: 1. Get all flows for the hospital 2. Get patient info for each flow 3. Get billing info for each flow 4. Return combined results 
     * Get billable tokens for a hospital
     */
    async getBillableTokens(hospitalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BillableTokenResponse>> {
        const response = await this.getBillableTokensRaw({ hospitalId: hospitalId }, initOverrides);
        return await response.value();
    }

    /**
     * Get flow for a patient in a hospital
     */
    async getFlowByPatientRaw(requestParameters: GetFlowByPatientRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Flow>> {
        if (requestParameters['patientId'] == null) {
            throw new runtime.RequiredError(
                'patientId',
                'Required parameter "patientId" was null or undefined when calling getFlowByPatient().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['patientId'] != null) {
            queryParameters['patientId'] = requestParameters['patientId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/flow/get-by-patient`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get flow for a patient in a hospital
     */
    async getFlowByPatient(patientId: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Flow> {
        const response = await this.getFlowByPatientRaw({ patientId: patientId }, initOverrides);
        return await response.value();
    }

    /**
     * Moves a patient to the next terminal in their flow sequence. This is a comprehensive operation that:  1. **Saves Current Terminal Data**: Persists all collected terminal data before transfer 2. **Removes from Current Queue**: Removes patient from current terminal\'s active queue 3. **Adds to Next Terminal Queue**: Adds patient to the next terminal\'s queue with calculated position 4. **Updates Flow State**: Updates flow progress and current terminal information 5. **Recalculates Queue Timing**: Adjusts estimated start times for all affected patients 6. **Sends Notifications**: Informs patients about queue changes via WhatsApp  The operation handles the complete transfer process atomically, ensuring data consistency and proper queue management across terminals. 
     * Move patient to next terminal in flow
     */
    async movePatientToNextTerminalRaw(requestParameters: MovePatientToNextTerminalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MoveToNextTerminalResponse>> {
        if (requestParameters['flowId'] == null) {
            throw new runtime.RequiredError(
                'flowId',
                'Required parameter "flowId" was null or undefined when calling movePatientToNextTerminal().'
            );
        }

        if (requestParameters['moveToNextTerminalRequest'] == null) {
            throw new runtime.RequiredError(
                'moveToNextTerminalRequest',
                'Required parameter "moveToNextTerminalRequest" was null or undefined when calling movePatientToNextTerminal().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/flow/move-to-next-terminal/{flowId}`;
        urlPath = urlPath.replace(`{${"flowId"}}`, encodeURIComponent(String(requestParameters['flowId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['moveToNextTerminalRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Moves a patient to the next terminal in their flow sequence. This is a comprehensive operation that:  1. **Saves Current Terminal Data**: Persists all collected terminal data before transfer 2. **Removes from Current Queue**: Removes patient from current terminal\'s active queue 3. **Adds to Next Terminal Queue**: Adds patient to the next terminal\'s queue with calculated position 4. **Updates Flow State**: Updates flow progress and current terminal information 5. **Recalculates Queue Timing**: Adjusts estimated start times for all affected patients 6. **Sends Notifications**: Informs patients about queue changes via WhatsApp  The operation handles the complete transfer process atomically, ensuring data consistency and proper queue management across terminals. 
     * Move patient to next terminal in flow
     */
    async movePatientToNextTerminal(flowId: string, moveToNextTerminalRequest: MoveToNextTerminalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MoveToNextTerminalResponse> {
        const response = await this.movePatientToNextTerminalRaw({ flowId: flowId, moveToNextTerminalRequest: moveToNextTerminalRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Save flow into flow history
     */
    async saveFlowRaw(requestParameters: SaveFlowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FlowHistory>> {
        if (requestParameters['flowId'] == null) {
            throw new runtime.RequiredError(
                'flowId',
                'Required parameter "flowId" was null or undefined when calling saveFlow().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/flow/save/{flowId}`;
        urlPath = urlPath.replace(`{${"flowId"}}`, encodeURIComponent(String(requestParameters['flowId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Save flow into flow history
     */
    async saveFlow(flowId: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FlowHistory> {
        const response = await this.saveFlowRaw({ flowId: flowId }, initOverrides);
        return await response.value();
    }

    /**
     * Update entries of a flow
     */
    async updateFlowDetailsRaw(requestParameters: UpdateFlowDetailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Flow>> {
        if (requestParameters['flowId'] == null) {
            throw new runtime.RequiredError(
                'flowId',
                'Required parameter "flowId" was null or undefined when calling updateFlowDetails().'
            );
        }

        if (requestParameters['flow'] == null) {
            throw new runtime.RequiredError(
                'flow',
                'Required parameter "flow" was null or undefined when calling updateFlowDetails().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/flow/update-flow-details/{flowId}`;
        urlPath = urlPath.replace(`{${"flowId"}}`, encodeURIComponent(String(requestParameters['flowId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['flow'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update entries of a flow
     */
    async updateFlowDetails(flowId: string, flow: Flow, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Flow> {
        const response = await this.updateFlowDetailsRaw({ flowId: flowId, flow: flow }, initOverrides);
        return await response.value();
    }

    /**
     * Update entries of a flow
     */
    async updateFlowEntriesRaw(requestParameters: UpdateFlowEntriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<FlowEntry>>> {
        if (requestParameters['flowId'] == null) {
            throw new runtime.RequiredError(
                'flowId',
                'Required parameter "flowId" was null or undefined when calling updateFlowEntries().'
            );
        }

        if (requestParameters['flowEntry'] == null) {
            throw new runtime.RequiredError(
                'flowEntry',
                'Required parameter "flowEntry" was null or undefined when calling updateFlowEntries().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/flow/update-entries/{flowId}`;
        urlPath = urlPath.replace(`{${"flowId"}}`, encodeURIComponent(String(requestParameters['flowId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['flowEntry'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update entries of a flow
     */
    async updateFlowEntries(flowId: string, flowEntry: Array<FlowEntry>, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<FlowEntry>> {
        const response = await this.updateFlowEntriesRaw({ flowId: flowId, flowEntry: flowEntry }, initOverrides);
        return await response.value();
    }

    /**
     * Update a specific flow entry
     */
    async updateFlowEntryRaw(requestParameters: UpdateFlowEntryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FlowEntry>> {
        if (requestParameters['flowId'] == null) {
            throw new runtime.RequiredError(
                'flowId',
                'Required parameter "flowId" was null or undefined when calling updateFlowEntry().'
            );
        }

        if (requestParameters['flowEntry'] == null) {
            throw new runtime.RequiredError(
                'flowEntry',
                'Required parameter "flowEntry" was null or undefined when calling updateFlowEntry().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/flow/update-entry/{flowId}`;
        urlPath = urlPath.replace(`{${"flowId"}}`, encodeURIComponent(String(requestParameters['flowId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['flowEntry'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update a specific flow entry
     */
    async updateFlowEntry(flowId: string, flowEntry: FlowEntry, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FlowEntry> {
        const response = await this.updateFlowEntryRaw({ flowId: flowId, flowEntry: flowEntry }, initOverrides);
        return await response.value();
    }

}
